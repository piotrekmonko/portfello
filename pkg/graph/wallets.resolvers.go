package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.42

import (
	"context"
	"fmt"
	"time"

	shortuuid "github.com/lithammer/shortuuid/v4"
	"github.com/piotrekmonko/portfello/pkg/auth"
	"github.com/piotrekmonko/portfello/pkg/dao"
	"github.com/piotrekmonko/portfello/pkg/graph/model"
)

// Description is the resolver for the description field.
func (r *expenseResolver) Description(ctx context.Context, obj *dao.Expense) (*string, error) {
	return obj.GetDescription(), nil
}

// CreateWallet is the resolver for the createWallet field.
func (r *mutationResolver) CreateWallet(ctx context.Context, input model.CreateWalletInput) ([]*dao.Wallet, error) {
	user := auth.GetCtxUser(ctx)
	if user == nil {
		return nil, auth.ErrNotAuthorized
	}

	q, rollBacker, err := r.DbDAO.BeginTx(ctx)
	if err != nil {
		return nil, fmt.Errorf("cannot crate new wallet: %w", err)
	}
	defer rollBacker()

	err = q.WalletInsert(ctx, &dao.WalletInsertParams{
		ID:        shortuuid.New(),
		UserID:    user.ID,
		Balance:   0,
		Currency:  "USD",
		CreatedAt: time.Time{},
	})
	if err != nil {
		return nil, fmt.Errorf("cannot crate new wallet: %w", err)
	}

	wallets, err := q.WalletsByUser(ctx, user.ID)
	if err != nil {
		return nil, fmt.Errorf("cannot list user wallets: %w", err)
	}

	return wallets, q.Commit(ctx)
}

// ListWallets is the resolver for the listWallets field.
func (r *queryResolver) ListWallets(ctx context.Context) ([]*dao.Wallet, error) {
	user := auth.GetCtxUser(ctx)
	if user == nil {
		return nil, auth.ErrNotAuthorized
	}

	return r.DbDAO.WalletsByUser(ctx, user.ID)
}

// ListWalletsByUserID is the resolver for the listWalletsByUserId field.
func (r *queryResolver) ListWalletsByUserID(ctx context.Context, userID string) ([]*dao.Wallet, error) {
	return r.DbDAO.WalletsByUser(ctx, userID)
}

// ListExpenses is the resolver for the listExpenses field.
func (r *queryResolver) ListExpenses(ctx context.Context, walletID string) ([]*dao.Expense, error) {
	user := auth.GetCtxUser(ctx)
	if user == nil {
		return nil, auth.ErrNotAuthorized
	}

	return r.DbDAO.ExpenseListByWalletByUser(ctx, walletID, user.ID)
}

// ListExpensesByUserID is the resolver for the listExpensesByUserId field.
func (r *queryResolver) ListExpensesByUserID(ctx context.Context, userID string, walletID string) ([]*dao.Expense, error) {
	return r.DbDAO.ExpenseListByWalletByUser(ctx, walletID, userID)
}

// Expense returns ExpenseResolver implementation.
func (r *Resolver) Expense() ExpenseResolver { return &expenseResolver{r} }

type expenseResolver struct{ *Resolver }
