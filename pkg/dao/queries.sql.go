// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.23.0
// source: queries.sql

package dao

import (
	"context"
	"database/sql"
	"time"
)

const expenseInsert = `-- name: ExpenseInsert :exec
INSERT INTO expense (id, wallet_id, amount, description, created_at) VALUES ($1, $2, $3, $4, $5)
`

type ExpenseInsertParams struct {
	ID          string
	WalletID    string
	Amount      float64
	Description sql.NullString
	CreatedAt   time.Time
}

func (q *Queries) ExpenseInsert(ctx context.Context, arg *ExpenseInsertParams) error {
	_, err := q.db.ExecContext(ctx, expenseInsert,
		arg.ID,
		arg.WalletID,
		arg.Amount,
		arg.Description,
		arg.CreatedAt,
	)
	return err
}

const expenseListByWallet = `-- name: ExpenseListByWallet :many
SELECT id, wallet_id, amount, description, created_at FROM expense WHERE wallet_id = $1 ORDER BY id
`

func (q *Queries) ExpenseListByWallet(ctx context.Context, walletID string) ([]*Expense, error) {
	rows, err := q.db.QueryContext(ctx, expenseListByWallet, walletID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Expense
	for rows.Next() {
		var i Expense
		if err := rows.Scan(
			&i.ID,
			&i.WalletID,
			&i.Amount,
			&i.Description,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const expenseListByWalletByUser = `-- name: ExpenseListByWalletByUser :many
SELECT id, wallet_id, amount, description, created_at FROM expense WHERE wallet_id = $1 AND wallet_id IN (
    SELECT id FROM wallet WHERE user_id = $2
) 
ORDER BY id
`

func (q *Queries) ExpenseListByWalletByUser(ctx context.Context, walletID string, userID string) ([]*Expense, error) {
	rows, err := q.db.QueryContext(ctx, expenseListByWalletByUser, walletID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Expense
	for rows.Next() {
		var i Expense
		if err := rows.Scan(
			&i.ID,
			&i.WalletID,
			&i.Amount,
			&i.Description,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const historyInsert = `-- name: HistoryInsert :exec
INSERT INTO history (id, namespace, reference, event, email, created_at) VALUES ($1, $2, $3, $4, $5, $6)
`

type HistoryInsertParams struct {
	ID        string
	Namespace string
	Reference string
	Event     string
	Email     string
	CreatedAt time.Time
}

func (q *Queries) HistoryInsert(ctx context.Context, arg *HistoryInsertParams) error {
	_, err := q.db.ExecContext(ctx, historyInsert,
		arg.ID,
		arg.Namespace,
		arg.Reference,
		arg.Event,
		arg.Email,
		arg.CreatedAt,
	)
	return err
}

const historyList = `-- name: HistoryList :many
SELECT id, namespace, reference, event, email, created_at FROM history ORDER BY id
`

func (q *Queries) HistoryList(ctx context.Context) ([]*History, error) {
	rows, err := q.db.QueryContext(ctx, historyList)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*History
	for rows.Next() {
		var i History
		if err := rows.Scan(
			&i.ID,
			&i.Namespace,
			&i.Reference,
			&i.Event,
			&i.Email,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const walletInsert = `-- name: WalletInsert :exec
INSERT INTO wallet (id, user_id, balance, currency, created_at) VALUES ($1, $2, $3, $4, $5)
`

type WalletInsertParams struct {
	ID        string
	UserID    string
	Balance   float64
	Currency  string
	CreatedAt time.Time
}

func (q *Queries) WalletInsert(ctx context.Context, arg *WalletInsertParams) error {
	_, err := q.db.ExecContext(ctx, walletInsert,
		arg.ID,
		arg.UserID,
		arg.Balance,
		arg.Currency,
		arg.CreatedAt,
	)
	return err
}

const walletUpdateBalance = `-- name: WalletUpdateBalance :exec
UPDATE wallet SET balance = $1 WHERE id = $2
`

func (q *Queries) WalletUpdateBalance(ctx context.Context, balance float64, iD string) error {
	_, err := q.db.ExecContext(ctx, walletUpdateBalance, balance, iD)
	return err
}

const walletsByUser = `-- name: WalletsByUser :many
SELECT id, user_id, balance, currency, created_at FROM wallet WHERE user_id = $1 ORDER BY wallet.created_at
`

func (q *Queries) WalletsByUser(ctx context.Context, userID string) ([]*Wallet, error) {
	rows, err := q.db.QueryContext(ctx, walletsByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Wallet
	for rows.Next() {
		var i Wallet
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Balance,
			&i.Currency,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
