// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: queries.sql

package dao

import (
	"context"
	"database/sql"
	"time"
)

const expenseInsert = `-- name: ExpenseInsert :exec
INSERT INTO expense (id, wallet_id, amount, description, created_at) VALUES ($1, $2, $3, $4, $5)
`

type ExpenseInsertParams struct {
	ID          string
	WalletID    string
	Amount      float64
	Description sql.NullString
	CreatedAt   time.Time
}

func (q *Queries) ExpenseInsert(ctx context.Context, arg *ExpenseInsertParams) error {
	_, err := q.db.ExecContext(ctx, expenseInsert,
		arg.ID,
		arg.WalletID,
		arg.Amount,
		arg.Description,
		arg.CreatedAt,
	)
	return err
}

const expenseListByWallet = `-- name: ExpenseListByWallet :many
SELECT id, wallet_id, amount, description, created_at FROM expense WHERE wallet_id = $1 ORDER BY id
`

func (q *Queries) ExpenseListByWallet(ctx context.Context, walletID string) ([]*Expense, error) {
	rows, err := q.db.QueryContext(ctx, expenseListByWallet, walletID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Expense
	for rows.Next() {
		var i Expense
		if err := rows.Scan(
			&i.ID,
			&i.WalletID,
			&i.Amount,
			&i.Description,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const expenseListByWalletByUser = `-- name: ExpenseListByWalletByUser :many
SELECT id, wallet_id, amount, description, created_at FROM expense WHERE wallet_id = $1 AND wallet_id IN (
    SELECT id FROM wallet WHERE user_id = $2
) 
ORDER BY id
`

func (q *Queries) ExpenseListByWalletByUser(ctx context.Context, walletID string, userID string) ([]*Expense, error) {
	rows, err := q.db.QueryContext(ctx, expenseListByWalletByUser, walletID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Expense
	for rows.Next() {
		var i Expense
		if err := rows.Scan(
			&i.ID,
			&i.WalletID,
			&i.Amount,
			&i.Description,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const historyInsert = `-- name: HistoryInsert :exec
INSERT INTO history (id, namespace, reference, event, email, created_at) VALUES ($1, $2, $3, $4, $5, $6)
`

type HistoryInsertParams struct {
	ID        string
	Namespace string
	Reference string
	Event     string
	Email     string
	CreatedAt time.Time
}

func (q *Queries) HistoryInsert(ctx context.Context, arg *HistoryInsertParams) error {
	_, err := q.db.ExecContext(ctx, historyInsert,
		arg.ID,
		arg.Namespace,
		arg.Reference,
		arg.Event,
		arg.Email,
		arg.CreatedAt,
	)
	return err
}

const historyList = `-- name: HistoryList :many
SELECT id, namespace, reference, event, email, created_at FROM history ORDER BY id
`

func (q *Queries) HistoryList(ctx context.Context) ([]*History, error) {
	rows, err := q.db.QueryContext(ctx, historyList)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*History
	for rows.Next() {
		var i History
		if err := rows.Scan(
			&i.ID,
			&i.Namespace,
			&i.Reference,
			&i.Event,
			&i.Email,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const localUserGetByEmail = `-- name: LocalUserGetByEmail :one
SELECT id, email, display_name, roles, pwdhash, created_at FROM local_user WHERE email = $1
`

func (q *Queries) LocalUserGetByEmail(ctx context.Context, email string) (*LocalUser, error) {
	row := q.db.QueryRowContext(ctx, localUserGetByEmail, email)
	var i LocalUser
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.DisplayName,
		&i.Roles,
		&i.Pwdhash,
		&i.CreatedAt,
	)
	return &i, err
}

const localUserGetByID = `-- name: LocalUserGetByID :one
SELECT id, email, display_name, roles, pwdhash, created_at FROM local_user WHERE id = $1
`

func (q *Queries) LocalUserGetByID(ctx context.Context, id string) (*LocalUser, error) {
	row := q.db.QueryRowContext(ctx, localUserGetByID, id)
	var i LocalUser
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.DisplayName,
		&i.Roles,
		&i.Pwdhash,
		&i.CreatedAt,
	)
	return &i, err
}

const localUserInsert = `-- name: LocalUserInsert :exec
INSERT INTO local_user (id, email, display_name, roles, created_at, pwdhash) VALUES ($1, $2, $3, $4, $5, $6)
`

type LocalUserInsertParams struct {
	ID          string
	Email       string
	DisplayName string
	Roles       string
	CreatedAt   time.Time
	Pwdhash     string
}

func (q *Queries) LocalUserInsert(ctx context.Context, arg *LocalUserInsertParams) error {
	_, err := q.db.ExecContext(ctx, localUserInsert,
		arg.ID,
		arg.Email,
		arg.DisplayName,
		arg.Roles,
		arg.CreatedAt,
		arg.Pwdhash,
	)
	return err
}

const localUserList = `-- name: LocalUserList :many
SELECT id, email, display_name, roles, pwdhash, created_at FROM local_user ORDER BY email
`

func (q *Queries) LocalUserList(ctx context.Context) ([]*LocalUser, error) {
	rows, err := q.db.QueryContext(ctx, localUserList)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*LocalUser
	for rows.Next() {
		var i LocalUser
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.DisplayName,
			&i.Roles,
			&i.Pwdhash,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const localUserSetPass = `-- name: LocalUserSetPass :exec
UPDATE local_user SET pwdhash = $1 WHERE email = $2
`

func (q *Queries) LocalUserSetPass(ctx context.Context, pwdhash string, email string) error {
	_, err := q.db.ExecContext(ctx, localUserSetPass, pwdhash, email)
	return err
}

const localUserUpdate = `-- name: LocalUserUpdate :exec
UPDATE local_user SET roles = $1 WHERE email = $2
`

func (q *Queries) LocalUserUpdate(ctx context.Context, roles string, email string) error {
	_, err := q.db.ExecContext(ctx, localUserUpdate, roles, email)
	return err
}

const walletInsert = `-- name: WalletInsert :exec
INSERT INTO wallet (id, user_id, balance, currency, created_at) VALUES ($1, $2, $3, $4, $5)
`

type WalletInsertParams struct {
	ID        string
	UserID    string
	Balance   float64
	Currency  string
	CreatedAt time.Time
}

func (q *Queries) WalletInsert(ctx context.Context, arg *WalletInsertParams) error {
	_, err := q.db.ExecContext(ctx, walletInsert,
		arg.ID,
		arg.UserID,
		arg.Balance,
		arg.Currency,
		arg.CreatedAt,
	)
	return err
}

const walletUpdateBalance = `-- name: WalletUpdateBalance :exec
UPDATE wallet SET balance = $1 WHERE id = $2
`

func (q *Queries) WalletUpdateBalance(ctx context.Context, balance float64, iD string) error {
	_, err := q.db.ExecContext(ctx, walletUpdateBalance, balance, iD)
	return err
}

const walletsByAdmin = `-- name: WalletsByAdmin :many
SELECT id, user_id, balance, currency, created_at FROM wallet ORDER BY wallet.user_id, wallet.created_at
`

func (q *Queries) WalletsByAdmin(ctx context.Context) ([]*Wallet, error) {
	rows, err := q.db.QueryContext(ctx, walletsByAdmin)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Wallet
	for rows.Next() {
		var i Wallet
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Balance,
			&i.Currency,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const walletsByUser = `-- name: WalletsByUser :many
SELECT id, user_id, balance, currency, created_at FROM wallet WHERE user_id = $1 ORDER BY wallet.created_at
`

func (q *Queries) WalletsByUser(ctx context.Context, userID string) ([]*Wallet, error) {
	rows, err := q.db.QueryContext(ctx, walletsByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Wallet
	for rows.Next() {
		var i Wallet
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Balance,
			&i.Currency,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
