// Code generated by mockery v2.40.3. DO NOT EDIT.

package mock_dao

import (
	context "context"

	dao "github.com/piotrekmonko/portfello/pkg/dao"
	mock "github.com/stretchr/testify/mock"

	sql "database/sql"
)

// MockDBInterface is an autogenerated mock type for the DBInterface type
type MockDBInterface struct {
	mock.Mock
}

type MockDBInterface_Expecter struct {
	mock *mock.Mock
}

func (_m *MockDBInterface) EXPECT() *MockDBInterface_Expecter {
	return &MockDBInterface_Expecter{mock: &_m.Mock}
}

// BeginTx provides a mock function with given fields: ctx
func (_m *MockDBInterface) BeginTx(ctx context.Context) (dao.DBInterface, func(), error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for BeginTx")
	}

	var r0 dao.DBInterface
	var r1 func()
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context) (dao.DBInterface, func(), error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) dao.DBInterface); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(dao.DBInterface)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) func()); ok {
		r1 = rf(ctx)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(func())
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context) error); ok {
		r2 = rf(ctx)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockDBInterface_BeginTx_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BeginTx'
type MockDBInterface_BeginTx_Call struct {
	*mock.Call
}

// BeginTx is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockDBInterface_Expecter) BeginTx(ctx interface{}) *MockDBInterface_BeginTx_Call {
	return &MockDBInterface_BeginTx_Call{Call: _e.mock.On("BeginTx", ctx)}
}

func (_c *MockDBInterface_BeginTx_Call) Run(run func(ctx context.Context)) *MockDBInterface_BeginTx_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockDBInterface_BeginTx_Call) Return(_a0 dao.DBInterface, _a1 func(), _a2 error) *MockDBInterface_BeginTx_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MockDBInterface_BeginTx_Call) RunAndReturn(run func(context.Context) (dao.DBInterface, func(), error)) *MockDBInterface_BeginTx_Call {
	_c.Call.Return(run)
	return _c
}

// Commit provides a mock function with given fields: ctx
func (_m *MockDBInterface) Commit(ctx context.Context) error {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Commit")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockDBInterface_Commit_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Commit'
type MockDBInterface_Commit_Call struct {
	*mock.Call
}

// Commit is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockDBInterface_Expecter) Commit(ctx interface{}) *MockDBInterface_Commit_Call {
	return &MockDBInterface_Commit_Call{Call: _e.mock.On("Commit", ctx)}
}

func (_c *MockDBInterface_Commit_Call) Run(run func(ctx context.Context)) *MockDBInterface_Commit_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockDBInterface_Commit_Call) Return(_a0 error) *MockDBInterface_Commit_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockDBInterface_Commit_Call) RunAndReturn(run func(context.Context) error) *MockDBInterface_Commit_Call {
	_c.Call.Return(run)
	return _c
}

// DB provides a mock function with given fields:
func (_m *MockDBInterface) DB() *sql.DB {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for DB")
	}

	var r0 *sql.DB
	if rf, ok := ret.Get(0).(func() *sql.DB); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*sql.DB)
		}
	}

	return r0
}

// MockDBInterface_DB_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DB'
type MockDBInterface_DB_Call struct {
	*mock.Call
}

// DB is a helper method to define mock.On call
func (_e *MockDBInterface_Expecter) DB() *MockDBInterface_DB_Call {
	return &MockDBInterface_DB_Call{Call: _e.mock.On("DB")}
}

func (_c *MockDBInterface_DB_Call) Run(run func()) *MockDBInterface_DB_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockDBInterface_DB_Call) Return(_a0 *sql.DB) *MockDBInterface_DB_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockDBInterface_DB_Call) RunAndReturn(run func() *sql.DB) *MockDBInterface_DB_Call {
	_c.Call.Return(run)
	return _c
}

// ExpenseInsert provides a mock function with given fields: ctx, arg
func (_m *MockDBInterface) ExpenseInsert(ctx context.Context, arg *dao.ExpenseInsertParams) error {
	ret := _m.Called(ctx, arg)

	if len(ret) == 0 {
		panic("no return value specified for ExpenseInsert")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *dao.ExpenseInsertParams) error); ok {
		r0 = rf(ctx, arg)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockDBInterface_ExpenseInsert_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ExpenseInsert'
type MockDBInterface_ExpenseInsert_Call struct {
	*mock.Call
}

// ExpenseInsert is a helper method to define mock.On call
//   - ctx context.Context
//   - arg *dao.ExpenseInsertParams
func (_e *MockDBInterface_Expecter) ExpenseInsert(ctx interface{}, arg interface{}) *MockDBInterface_ExpenseInsert_Call {
	return &MockDBInterface_ExpenseInsert_Call{Call: _e.mock.On("ExpenseInsert", ctx, arg)}
}

func (_c *MockDBInterface_ExpenseInsert_Call) Run(run func(ctx context.Context, arg *dao.ExpenseInsertParams)) *MockDBInterface_ExpenseInsert_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*dao.ExpenseInsertParams))
	})
	return _c
}

func (_c *MockDBInterface_ExpenseInsert_Call) Return(_a0 error) *MockDBInterface_ExpenseInsert_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockDBInterface_ExpenseInsert_Call) RunAndReturn(run func(context.Context, *dao.ExpenseInsertParams) error) *MockDBInterface_ExpenseInsert_Call {
	_c.Call.Return(run)
	return _c
}

// ExpenseListByWallet provides a mock function with given fields: ctx, walletID
func (_m *MockDBInterface) ExpenseListByWallet(ctx context.Context, walletID string) ([]*dao.Expense, error) {
	ret := _m.Called(ctx, walletID)

	if len(ret) == 0 {
		panic("no return value specified for ExpenseListByWallet")
	}

	var r0 []*dao.Expense
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) ([]*dao.Expense, error)); ok {
		return rf(ctx, walletID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) []*dao.Expense); ok {
		r0 = rf(ctx, walletID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*dao.Expense)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, walletID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDBInterface_ExpenseListByWallet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ExpenseListByWallet'
type MockDBInterface_ExpenseListByWallet_Call struct {
	*mock.Call
}

// ExpenseListByWallet is a helper method to define mock.On call
//   - ctx context.Context
//   - walletID string
func (_e *MockDBInterface_Expecter) ExpenseListByWallet(ctx interface{}, walletID interface{}) *MockDBInterface_ExpenseListByWallet_Call {
	return &MockDBInterface_ExpenseListByWallet_Call{Call: _e.mock.On("ExpenseListByWallet", ctx, walletID)}
}

func (_c *MockDBInterface_ExpenseListByWallet_Call) Run(run func(ctx context.Context, walletID string)) *MockDBInterface_ExpenseListByWallet_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockDBInterface_ExpenseListByWallet_Call) Return(_a0 []*dao.Expense, _a1 error) *MockDBInterface_ExpenseListByWallet_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDBInterface_ExpenseListByWallet_Call) RunAndReturn(run func(context.Context, string) ([]*dao.Expense, error)) *MockDBInterface_ExpenseListByWallet_Call {
	_c.Call.Return(run)
	return _c
}

// ExpenseListByWalletByUser provides a mock function with given fields: ctx, walletID, userID
func (_m *MockDBInterface) ExpenseListByWalletByUser(ctx context.Context, walletID string, userID string) ([]*dao.Expense, error) {
	ret := _m.Called(ctx, walletID, userID)

	if len(ret) == 0 {
		panic("no return value specified for ExpenseListByWalletByUser")
	}

	var r0 []*dao.Expense
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) ([]*dao.Expense, error)); ok {
		return rf(ctx, walletID, userID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) []*dao.Expense); ok {
		r0 = rf(ctx, walletID, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*dao.Expense)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, walletID, userID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDBInterface_ExpenseListByWalletByUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ExpenseListByWalletByUser'
type MockDBInterface_ExpenseListByWalletByUser_Call struct {
	*mock.Call
}

// ExpenseListByWalletByUser is a helper method to define mock.On call
//   - ctx context.Context
//   - walletID string
//   - userID string
func (_e *MockDBInterface_Expecter) ExpenseListByWalletByUser(ctx interface{}, walletID interface{}, userID interface{}) *MockDBInterface_ExpenseListByWalletByUser_Call {
	return &MockDBInterface_ExpenseListByWalletByUser_Call{Call: _e.mock.On("ExpenseListByWalletByUser", ctx, walletID, userID)}
}

func (_c *MockDBInterface_ExpenseListByWalletByUser_Call) Run(run func(ctx context.Context, walletID string, userID string)) *MockDBInterface_ExpenseListByWalletByUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockDBInterface_ExpenseListByWalletByUser_Call) Return(_a0 []*dao.Expense, _a1 error) *MockDBInterface_ExpenseListByWalletByUser_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDBInterface_ExpenseListByWalletByUser_Call) RunAndReturn(run func(context.Context, string, string) ([]*dao.Expense, error)) *MockDBInterface_ExpenseListByWalletByUser_Call {
	_c.Call.Return(run)
	return _c
}

// HistoryInsert provides a mock function with given fields: ctx, arg
func (_m *MockDBInterface) HistoryInsert(ctx context.Context, arg *dao.HistoryInsertParams) error {
	ret := _m.Called(ctx, arg)

	if len(ret) == 0 {
		panic("no return value specified for HistoryInsert")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *dao.HistoryInsertParams) error); ok {
		r0 = rf(ctx, arg)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockDBInterface_HistoryInsert_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HistoryInsert'
type MockDBInterface_HistoryInsert_Call struct {
	*mock.Call
}

// HistoryInsert is a helper method to define mock.On call
//   - ctx context.Context
//   - arg *dao.HistoryInsertParams
func (_e *MockDBInterface_Expecter) HistoryInsert(ctx interface{}, arg interface{}) *MockDBInterface_HistoryInsert_Call {
	return &MockDBInterface_HistoryInsert_Call{Call: _e.mock.On("HistoryInsert", ctx, arg)}
}

func (_c *MockDBInterface_HistoryInsert_Call) Run(run func(ctx context.Context, arg *dao.HistoryInsertParams)) *MockDBInterface_HistoryInsert_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*dao.HistoryInsertParams))
	})
	return _c
}

func (_c *MockDBInterface_HistoryInsert_Call) Return(_a0 error) *MockDBInterface_HistoryInsert_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockDBInterface_HistoryInsert_Call) RunAndReturn(run func(context.Context, *dao.HistoryInsertParams) error) *MockDBInterface_HistoryInsert_Call {
	_c.Call.Return(run)
	return _c
}

// HistoryList provides a mock function with given fields: ctx
func (_m *MockDBInterface) HistoryList(ctx context.Context) ([]*dao.History, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for HistoryList")
	}

	var r0 []*dao.History
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) ([]*dao.History, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) []*dao.History); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*dao.History)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDBInterface_HistoryList_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HistoryList'
type MockDBInterface_HistoryList_Call struct {
	*mock.Call
}

// HistoryList is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockDBInterface_Expecter) HistoryList(ctx interface{}) *MockDBInterface_HistoryList_Call {
	return &MockDBInterface_HistoryList_Call{Call: _e.mock.On("HistoryList", ctx)}
}

func (_c *MockDBInterface_HistoryList_Call) Run(run func(ctx context.Context)) *MockDBInterface_HistoryList_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockDBInterface_HistoryList_Call) Return(_a0 []*dao.History, _a1 error) *MockDBInterface_HistoryList_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDBInterface_HistoryList_Call) RunAndReturn(run func(context.Context) ([]*dao.History, error)) *MockDBInterface_HistoryList_Call {
	_c.Call.Return(run)
	return _c
}

// LocalUserGetByEmail provides a mock function with given fields: ctx, email
func (_m *MockDBInterface) LocalUserGetByEmail(ctx context.Context, email string) (*dao.LocalUser, error) {
	ret := _m.Called(ctx, email)

	if len(ret) == 0 {
		panic("no return value specified for LocalUserGetByEmail")
	}

	var r0 *dao.LocalUser
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*dao.LocalUser, error)); ok {
		return rf(ctx, email)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *dao.LocalUser); ok {
		r0 = rf(ctx, email)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*dao.LocalUser)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, email)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDBInterface_LocalUserGetByEmail_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LocalUserGetByEmail'
type MockDBInterface_LocalUserGetByEmail_Call struct {
	*mock.Call
}

// LocalUserGetByEmail is a helper method to define mock.On call
//   - ctx context.Context
//   - email string
func (_e *MockDBInterface_Expecter) LocalUserGetByEmail(ctx interface{}, email interface{}) *MockDBInterface_LocalUserGetByEmail_Call {
	return &MockDBInterface_LocalUserGetByEmail_Call{Call: _e.mock.On("LocalUserGetByEmail", ctx, email)}
}

func (_c *MockDBInterface_LocalUserGetByEmail_Call) Run(run func(ctx context.Context, email string)) *MockDBInterface_LocalUserGetByEmail_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockDBInterface_LocalUserGetByEmail_Call) Return(_a0 *dao.LocalUser, _a1 error) *MockDBInterface_LocalUserGetByEmail_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDBInterface_LocalUserGetByEmail_Call) RunAndReturn(run func(context.Context, string) (*dao.LocalUser, error)) *MockDBInterface_LocalUserGetByEmail_Call {
	_c.Call.Return(run)
	return _c
}

// LocalUserGetByID provides a mock function with given fields: ctx, id
func (_m *MockDBInterface) LocalUserGetByID(ctx context.Context, id string) (*dao.LocalUser, error) {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for LocalUserGetByID")
	}

	var r0 *dao.LocalUser
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*dao.LocalUser, error)); ok {
		return rf(ctx, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *dao.LocalUser); ok {
		r0 = rf(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*dao.LocalUser)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDBInterface_LocalUserGetByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LocalUserGetByID'
type MockDBInterface_LocalUserGetByID_Call struct {
	*mock.Call
}

// LocalUserGetByID is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
func (_e *MockDBInterface_Expecter) LocalUserGetByID(ctx interface{}, id interface{}) *MockDBInterface_LocalUserGetByID_Call {
	return &MockDBInterface_LocalUserGetByID_Call{Call: _e.mock.On("LocalUserGetByID", ctx, id)}
}

func (_c *MockDBInterface_LocalUserGetByID_Call) Run(run func(ctx context.Context, id string)) *MockDBInterface_LocalUserGetByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockDBInterface_LocalUserGetByID_Call) Return(_a0 *dao.LocalUser, _a1 error) *MockDBInterface_LocalUserGetByID_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDBInterface_LocalUserGetByID_Call) RunAndReturn(run func(context.Context, string) (*dao.LocalUser, error)) *MockDBInterface_LocalUserGetByID_Call {
	_c.Call.Return(run)
	return _c
}

// LocalUserInsert provides a mock function with given fields: ctx, arg
func (_m *MockDBInterface) LocalUserInsert(ctx context.Context, arg *dao.LocalUserInsertParams) error {
	ret := _m.Called(ctx, arg)

	if len(ret) == 0 {
		panic("no return value specified for LocalUserInsert")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *dao.LocalUserInsertParams) error); ok {
		r0 = rf(ctx, arg)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockDBInterface_LocalUserInsert_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LocalUserInsert'
type MockDBInterface_LocalUserInsert_Call struct {
	*mock.Call
}

// LocalUserInsert is a helper method to define mock.On call
//   - ctx context.Context
//   - arg *dao.LocalUserInsertParams
func (_e *MockDBInterface_Expecter) LocalUserInsert(ctx interface{}, arg interface{}) *MockDBInterface_LocalUserInsert_Call {
	return &MockDBInterface_LocalUserInsert_Call{Call: _e.mock.On("LocalUserInsert", ctx, arg)}
}

func (_c *MockDBInterface_LocalUserInsert_Call) Run(run func(ctx context.Context, arg *dao.LocalUserInsertParams)) *MockDBInterface_LocalUserInsert_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*dao.LocalUserInsertParams))
	})
	return _c
}

func (_c *MockDBInterface_LocalUserInsert_Call) Return(_a0 error) *MockDBInterface_LocalUserInsert_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockDBInterface_LocalUserInsert_Call) RunAndReturn(run func(context.Context, *dao.LocalUserInsertParams) error) *MockDBInterface_LocalUserInsert_Call {
	_c.Call.Return(run)
	return _c
}

// LocalUserList provides a mock function with given fields: ctx
func (_m *MockDBInterface) LocalUserList(ctx context.Context) ([]*dao.LocalUser, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for LocalUserList")
	}

	var r0 []*dao.LocalUser
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) ([]*dao.LocalUser, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) []*dao.LocalUser); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*dao.LocalUser)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDBInterface_LocalUserList_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LocalUserList'
type MockDBInterface_LocalUserList_Call struct {
	*mock.Call
}

// LocalUserList is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockDBInterface_Expecter) LocalUserList(ctx interface{}) *MockDBInterface_LocalUserList_Call {
	return &MockDBInterface_LocalUserList_Call{Call: _e.mock.On("LocalUserList", ctx)}
}

func (_c *MockDBInterface_LocalUserList_Call) Run(run func(ctx context.Context)) *MockDBInterface_LocalUserList_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockDBInterface_LocalUserList_Call) Return(_a0 []*dao.LocalUser, _a1 error) *MockDBInterface_LocalUserList_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDBInterface_LocalUserList_Call) RunAndReturn(run func(context.Context) ([]*dao.LocalUser, error)) *MockDBInterface_LocalUserList_Call {
	_c.Call.Return(run)
	return _c
}

// LocalUserSetPass provides a mock function with given fields: ctx, pwdhash, email
func (_m *MockDBInterface) LocalUserSetPass(ctx context.Context, pwdhash string, email string) error {
	ret := _m.Called(ctx, pwdhash, email)

	if len(ret) == 0 {
		panic("no return value specified for LocalUserSetPass")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, pwdhash, email)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockDBInterface_LocalUserSetPass_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LocalUserSetPass'
type MockDBInterface_LocalUserSetPass_Call struct {
	*mock.Call
}

// LocalUserSetPass is a helper method to define mock.On call
//   - ctx context.Context
//   - pwdhash string
//   - email string
func (_e *MockDBInterface_Expecter) LocalUserSetPass(ctx interface{}, pwdhash interface{}, email interface{}) *MockDBInterface_LocalUserSetPass_Call {
	return &MockDBInterface_LocalUserSetPass_Call{Call: _e.mock.On("LocalUserSetPass", ctx, pwdhash, email)}
}

func (_c *MockDBInterface_LocalUserSetPass_Call) Run(run func(ctx context.Context, pwdhash string, email string)) *MockDBInterface_LocalUserSetPass_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockDBInterface_LocalUserSetPass_Call) Return(_a0 error) *MockDBInterface_LocalUserSetPass_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockDBInterface_LocalUserSetPass_Call) RunAndReturn(run func(context.Context, string, string) error) *MockDBInterface_LocalUserSetPass_Call {
	_c.Call.Return(run)
	return _c
}

// LocalUserUpdate provides a mock function with given fields: ctx, roles, email
func (_m *MockDBInterface) LocalUserUpdate(ctx context.Context, roles string, email string) error {
	ret := _m.Called(ctx, roles, email)

	if len(ret) == 0 {
		panic("no return value specified for LocalUserUpdate")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, roles, email)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockDBInterface_LocalUserUpdate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LocalUserUpdate'
type MockDBInterface_LocalUserUpdate_Call struct {
	*mock.Call
}

// LocalUserUpdate is a helper method to define mock.On call
//   - ctx context.Context
//   - roles string
//   - email string
func (_e *MockDBInterface_Expecter) LocalUserUpdate(ctx interface{}, roles interface{}, email interface{}) *MockDBInterface_LocalUserUpdate_Call {
	return &MockDBInterface_LocalUserUpdate_Call{Call: _e.mock.On("LocalUserUpdate", ctx, roles, email)}
}

func (_c *MockDBInterface_LocalUserUpdate_Call) Run(run func(ctx context.Context, roles string, email string)) *MockDBInterface_LocalUserUpdate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockDBInterface_LocalUserUpdate_Call) Return(_a0 error) *MockDBInterface_LocalUserUpdate_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockDBInterface_LocalUserUpdate_Call) RunAndReturn(run func(context.Context, string, string) error) *MockDBInterface_LocalUserUpdate_Call {
	_c.Call.Return(run)
	return _c
}

// Ping provides a mock function with given fields: ctx
func (_m *MockDBInterface) Ping(ctx context.Context) error {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Ping")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockDBInterface_Ping_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Ping'
type MockDBInterface_Ping_Call struct {
	*mock.Call
}

// Ping is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockDBInterface_Expecter) Ping(ctx interface{}) *MockDBInterface_Ping_Call {
	return &MockDBInterface_Ping_Call{Call: _e.mock.On("Ping", ctx)}
}

func (_c *MockDBInterface_Ping_Call) Run(run func(ctx context.Context)) *MockDBInterface_Ping_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockDBInterface_Ping_Call) Return(_a0 error) *MockDBInterface_Ping_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockDBInterface_Ping_Call) RunAndReturn(run func(context.Context) error) *MockDBInterface_Ping_Call {
	_c.Call.Return(run)
	return _c
}

// WalletInsert provides a mock function with given fields: ctx, arg
func (_m *MockDBInterface) WalletInsert(ctx context.Context, arg *dao.WalletInsertParams) error {
	ret := _m.Called(ctx, arg)

	if len(ret) == 0 {
		panic("no return value specified for WalletInsert")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *dao.WalletInsertParams) error); ok {
		r0 = rf(ctx, arg)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockDBInterface_WalletInsert_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WalletInsert'
type MockDBInterface_WalletInsert_Call struct {
	*mock.Call
}

// WalletInsert is a helper method to define mock.On call
//   - ctx context.Context
//   - arg *dao.WalletInsertParams
func (_e *MockDBInterface_Expecter) WalletInsert(ctx interface{}, arg interface{}) *MockDBInterface_WalletInsert_Call {
	return &MockDBInterface_WalletInsert_Call{Call: _e.mock.On("WalletInsert", ctx, arg)}
}

func (_c *MockDBInterface_WalletInsert_Call) Run(run func(ctx context.Context, arg *dao.WalletInsertParams)) *MockDBInterface_WalletInsert_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*dao.WalletInsertParams))
	})
	return _c
}

func (_c *MockDBInterface_WalletInsert_Call) Return(_a0 error) *MockDBInterface_WalletInsert_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockDBInterface_WalletInsert_Call) RunAndReturn(run func(context.Context, *dao.WalletInsertParams) error) *MockDBInterface_WalletInsert_Call {
	_c.Call.Return(run)
	return _c
}

// WalletUpdateBalance provides a mock function with given fields: ctx, balance, iD
func (_m *MockDBInterface) WalletUpdateBalance(ctx context.Context, balance float64, iD string) error {
	ret := _m.Called(ctx, balance, iD)

	if len(ret) == 0 {
		panic("no return value specified for WalletUpdateBalance")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, float64, string) error); ok {
		r0 = rf(ctx, balance, iD)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockDBInterface_WalletUpdateBalance_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WalletUpdateBalance'
type MockDBInterface_WalletUpdateBalance_Call struct {
	*mock.Call
}

// WalletUpdateBalance is a helper method to define mock.On call
//   - ctx context.Context
//   - balance float64
//   - iD string
func (_e *MockDBInterface_Expecter) WalletUpdateBalance(ctx interface{}, balance interface{}, iD interface{}) *MockDBInterface_WalletUpdateBalance_Call {
	return &MockDBInterface_WalletUpdateBalance_Call{Call: _e.mock.On("WalletUpdateBalance", ctx, balance, iD)}
}

func (_c *MockDBInterface_WalletUpdateBalance_Call) Run(run func(ctx context.Context, balance float64, iD string)) *MockDBInterface_WalletUpdateBalance_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(float64), args[2].(string))
	})
	return _c
}

func (_c *MockDBInterface_WalletUpdateBalance_Call) Return(_a0 error) *MockDBInterface_WalletUpdateBalance_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockDBInterface_WalletUpdateBalance_Call) RunAndReturn(run func(context.Context, float64, string) error) *MockDBInterface_WalletUpdateBalance_Call {
	_c.Call.Return(run)
	return _c
}

// WalletsByAdmin provides a mock function with given fields: ctx
func (_m *MockDBInterface) WalletsByAdmin(ctx context.Context) ([]*dao.Wallet, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for WalletsByAdmin")
	}

	var r0 []*dao.Wallet
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) ([]*dao.Wallet, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) []*dao.Wallet); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*dao.Wallet)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDBInterface_WalletsByAdmin_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WalletsByAdmin'
type MockDBInterface_WalletsByAdmin_Call struct {
	*mock.Call
}

// WalletsByAdmin is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockDBInterface_Expecter) WalletsByAdmin(ctx interface{}) *MockDBInterface_WalletsByAdmin_Call {
	return &MockDBInterface_WalletsByAdmin_Call{Call: _e.mock.On("WalletsByAdmin", ctx)}
}

func (_c *MockDBInterface_WalletsByAdmin_Call) Run(run func(ctx context.Context)) *MockDBInterface_WalletsByAdmin_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockDBInterface_WalletsByAdmin_Call) Return(_a0 []*dao.Wallet, _a1 error) *MockDBInterface_WalletsByAdmin_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDBInterface_WalletsByAdmin_Call) RunAndReturn(run func(context.Context) ([]*dao.Wallet, error)) *MockDBInterface_WalletsByAdmin_Call {
	_c.Call.Return(run)
	return _c
}

// WalletsByUser provides a mock function with given fields: ctx, userID
func (_m *MockDBInterface) WalletsByUser(ctx context.Context, userID string) ([]*dao.Wallet, error) {
	ret := _m.Called(ctx, userID)

	if len(ret) == 0 {
		panic("no return value specified for WalletsByUser")
	}

	var r0 []*dao.Wallet
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) ([]*dao.Wallet, error)); ok {
		return rf(ctx, userID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) []*dao.Wallet); ok {
		r0 = rf(ctx, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*dao.Wallet)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, userID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDBInterface_WalletsByUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WalletsByUser'
type MockDBInterface_WalletsByUser_Call struct {
	*mock.Call
}

// WalletsByUser is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
func (_e *MockDBInterface_Expecter) WalletsByUser(ctx interface{}, userID interface{}) *MockDBInterface_WalletsByUser_Call {
	return &MockDBInterface_WalletsByUser_Call{Call: _e.mock.On("WalletsByUser", ctx, userID)}
}

func (_c *MockDBInterface_WalletsByUser_Call) Run(run func(ctx context.Context, userID string)) *MockDBInterface_WalletsByUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockDBInterface_WalletsByUser_Call) Return(_a0 []*dao.Wallet, _a1 error) *MockDBInterface_WalletsByUser_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDBInterface_WalletsByUser_Call) RunAndReturn(run func(context.Context, string) ([]*dao.Wallet, error)) *MockDBInterface_WalletsByUser_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockDBInterface creates a new instance of MockDBInterface. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockDBInterface(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockDBInterface {
	mock := &MockDBInterface{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
