// Code generated by mockery v2.40.3. DO NOT EDIT.

package mock_dao

import (
	context "context"

	dao "github.com/piotrekmonko/portfello/pkg/dao"
	mock "github.com/stretchr/testify/mock"
)

// MockQuerier is an autogenerated mock type for the Querier type
type MockQuerier struct {
	mock.Mock
}

type MockQuerier_Expecter struct {
	mock *mock.Mock
}

func (_m *MockQuerier) EXPECT() *MockQuerier_Expecter {
	return &MockQuerier_Expecter{mock: &_m.Mock}
}

// ExpenseInsert provides a mock function with given fields: ctx, arg
func (_m *MockQuerier) ExpenseInsert(ctx context.Context, arg *dao.ExpenseInsertParams) error {
	ret := _m.Called(ctx, arg)

	if len(ret) == 0 {
		panic("no return value specified for ExpenseInsert")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *dao.ExpenseInsertParams) error); ok {
		r0 = rf(ctx, arg)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockQuerier_ExpenseInsert_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ExpenseInsert'
type MockQuerier_ExpenseInsert_Call struct {
	*mock.Call
}

// ExpenseInsert is a helper method to define mock.On call
//   - ctx context.Context
//   - arg *dao.ExpenseInsertParams
func (_e *MockQuerier_Expecter) ExpenseInsert(ctx interface{}, arg interface{}) *MockQuerier_ExpenseInsert_Call {
	return &MockQuerier_ExpenseInsert_Call{Call: _e.mock.On("ExpenseInsert", ctx, arg)}
}

func (_c *MockQuerier_ExpenseInsert_Call) Run(run func(ctx context.Context, arg *dao.ExpenseInsertParams)) *MockQuerier_ExpenseInsert_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*dao.ExpenseInsertParams))
	})
	return _c
}

func (_c *MockQuerier_ExpenseInsert_Call) Return(_a0 error) *MockQuerier_ExpenseInsert_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockQuerier_ExpenseInsert_Call) RunAndReturn(run func(context.Context, *dao.ExpenseInsertParams) error) *MockQuerier_ExpenseInsert_Call {
	_c.Call.Return(run)
	return _c
}

// ExpenseListByWallet provides a mock function with given fields: ctx, walletID
func (_m *MockQuerier) ExpenseListByWallet(ctx context.Context, walletID string) ([]*dao.Expense, error) {
	ret := _m.Called(ctx, walletID)

	if len(ret) == 0 {
		panic("no return value specified for ExpenseListByWallet")
	}

	var r0 []*dao.Expense
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) ([]*dao.Expense, error)); ok {
		return rf(ctx, walletID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) []*dao.Expense); ok {
		r0 = rf(ctx, walletID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*dao.Expense)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, walletID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_ExpenseListByWallet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ExpenseListByWallet'
type MockQuerier_ExpenseListByWallet_Call struct {
	*mock.Call
}

// ExpenseListByWallet is a helper method to define mock.On call
//   - ctx context.Context
//   - walletID string
func (_e *MockQuerier_Expecter) ExpenseListByWallet(ctx interface{}, walletID interface{}) *MockQuerier_ExpenseListByWallet_Call {
	return &MockQuerier_ExpenseListByWallet_Call{Call: _e.mock.On("ExpenseListByWallet", ctx, walletID)}
}

func (_c *MockQuerier_ExpenseListByWallet_Call) Run(run func(ctx context.Context, walletID string)) *MockQuerier_ExpenseListByWallet_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockQuerier_ExpenseListByWallet_Call) Return(_a0 []*dao.Expense, _a1 error) *MockQuerier_ExpenseListByWallet_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_ExpenseListByWallet_Call) RunAndReturn(run func(context.Context, string) ([]*dao.Expense, error)) *MockQuerier_ExpenseListByWallet_Call {
	_c.Call.Return(run)
	return _c
}

// ExpenseListByWalletByUser provides a mock function with given fields: ctx, walletID, userID
func (_m *MockQuerier) ExpenseListByWalletByUser(ctx context.Context, walletID string, userID string) ([]*dao.Expense, error) {
	ret := _m.Called(ctx, walletID, userID)

	if len(ret) == 0 {
		panic("no return value specified for ExpenseListByWalletByUser")
	}

	var r0 []*dao.Expense
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) ([]*dao.Expense, error)); ok {
		return rf(ctx, walletID, userID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) []*dao.Expense); ok {
		r0 = rf(ctx, walletID, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*dao.Expense)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, walletID, userID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_ExpenseListByWalletByUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ExpenseListByWalletByUser'
type MockQuerier_ExpenseListByWalletByUser_Call struct {
	*mock.Call
}

// ExpenseListByWalletByUser is a helper method to define mock.On call
//   - ctx context.Context
//   - walletID string
//   - userID string
func (_e *MockQuerier_Expecter) ExpenseListByWalletByUser(ctx interface{}, walletID interface{}, userID interface{}) *MockQuerier_ExpenseListByWalletByUser_Call {
	return &MockQuerier_ExpenseListByWalletByUser_Call{Call: _e.mock.On("ExpenseListByWalletByUser", ctx, walletID, userID)}
}

func (_c *MockQuerier_ExpenseListByWalletByUser_Call) Run(run func(ctx context.Context, walletID string, userID string)) *MockQuerier_ExpenseListByWalletByUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockQuerier_ExpenseListByWalletByUser_Call) Return(_a0 []*dao.Expense, _a1 error) *MockQuerier_ExpenseListByWalletByUser_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_ExpenseListByWalletByUser_Call) RunAndReturn(run func(context.Context, string, string) ([]*dao.Expense, error)) *MockQuerier_ExpenseListByWalletByUser_Call {
	_c.Call.Return(run)
	return _c
}

// HistoryInsert provides a mock function with given fields: ctx, arg
func (_m *MockQuerier) HistoryInsert(ctx context.Context, arg *dao.HistoryInsertParams) error {
	ret := _m.Called(ctx, arg)

	if len(ret) == 0 {
		panic("no return value specified for HistoryInsert")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *dao.HistoryInsertParams) error); ok {
		r0 = rf(ctx, arg)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockQuerier_HistoryInsert_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HistoryInsert'
type MockQuerier_HistoryInsert_Call struct {
	*mock.Call
}

// HistoryInsert is a helper method to define mock.On call
//   - ctx context.Context
//   - arg *dao.HistoryInsertParams
func (_e *MockQuerier_Expecter) HistoryInsert(ctx interface{}, arg interface{}) *MockQuerier_HistoryInsert_Call {
	return &MockQuerier_HistoryInsert_Call{Call: _e.mock.On("HistoryInsert", ctx, arg)}
}

func (_c *MockQuerier_HistoryInsert_Call) Run(run func(ctx context.Context, arg *dao.HistoryInsertParams)) *MockQuerier_HistoryInsert_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*dao.HistoryInsertParams))
	})
	return _c
}

func (_c *MockQuerier_HistoryInsert_Call) Return(_a0 error) *MockQuerier_HistoryInsert_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockQuerier_HistoryInsert_Call) RunAndReturn(run func(context.Context, *dao.HistoryInsertParams) error) *MockQuerier_HistoryInsert_Call {
	_c.Call.Return(run)
	return _c
}

// HistoryList provides a mock function with given fields: ctx
func (_m *MockQuerier) HistoryList(ctx context.Context) ([]*dao.History, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for HistoryList")
	}

	var r0 []*dao.History
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) ([]*dao.History, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) []*dao.History); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*dao.History)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_HistoryList_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HistoryList'
type MockQuerier_HistoryList_Call struct {
	*mock.Call
}

// HistoryList is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockQuerier_Expecter) HistoryList(ctx interface{}) *MockQuerier_HistoryList_Call {
	return &MockQuerier_HistoryList_Call{Call: _e.mock.On("HistoryList", ctx)}
}

func (_c *MockQuerier_HistoryList_Call) Run(run func(ctx context.Context)) *MockQuerier_HistoryList_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockQuerier_HistoryList_Call) Return(_a0 []*dao.History, _a1 error) *MockQuerier_HistoryList_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_HistoryList_Call) RunAndReturn(run func(context.Context) ([]*dao.History, error)) *MockQuerier_HistoryList_Call {
	_c.Call.Return(run)
	return _c
}

// LocalUserGetByEmail provides a mock function with given fields: ctx, email
func (_m *MockQuerier) LocalUserGetByEmail(ctx context.Context, email string) (*dao.LocalUser, error) {
	ret := _m.Called(ctx, email)

	if len(ret) == 0 {
		panic("no return value specified for LocalUserGetByEmail")
	}

	var r0 *dao.LocalUser
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*dao.LocalUser, error)); ok {
		return rf(ctx, email)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *dao.LocalUser); ok {
		r0 = rf(ctx, email)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*dao.LocalUser)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, email)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_LocalUserGetByEmail_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LocalUserGetByEmail'
type MockQuerier_LocalUserGetByEmail_Call struct {
	*mock.Call
}

// LocalUserGetByEmail is a helper method to define mock.On call
//   - ctx context.Context
//   - email string
func (_e *MockQuerier_Expecter) LocalUserGetByEmail(ctx interface{}, email interface{}) *MockQuerier_LocalUserGetByEmail_Call {
	return &MockQuerier_LocalUserGetByEmail_Call{Call: _e.mock.On("LocalUserGetByEmail", ctx, email)}
}

func (_c *MockQuerier_LocalUserGetByEmail_Call) Run(run func(ctx context.Context, email string)) *MockQuerier_LocalUserGetByEmail_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockQuerier_LocalUserGetByEmail_Call) Return(_a0 *dao.LocalUser, _a1 error) *MockQuerier_LocalUserGetByEmail_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_LocalUserGetByEmail_Call) RunAndReturn(run func(context.Context, string) (*dao.LocalUser, error)) *MockQuerier_LocalUserGetByEmail_Call {
	_c.Call.Return(run)
	return _c
}

// LocalUserGetByID provides a mock function with given fields: ctx, id
func (_m *MockQuerier) LocalUserGetByID(ctx context.Context, id string) (*dao.LocalUser, error) {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for LocalUserGetByID")
	}

	var r0 *dao.LocalUser
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*dao.LocalUser, error)); ok {
		return rf(ctx, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *dao.LocalUser); ok {
		r0 = rf(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*dao.LocalUser)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_LocalUserGetByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LocalUserGetByID'
type MockQuerier_LocalUserGetByID_Call struct {
	*mock.Call
}

// LocalUserGetByID is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
func (_e *MockQuerier_Expecter) LocalUserGetByID(ctx interface{}, id interface{}) *MockQuerier_LocalUserGetByID_Call {
	return &MockQuerier_LocalUserGetByID_Call{Call: _e.mock.On("LocalUserGetByID", ctx, id)}
}

func (_c *MockQuerier_LocalUserGetByID_Call) Run(run func(ctx context.Context, id string)) *MockQuerier_LocalUserGetByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockQuerier_LocalUserGetByID_Call) Return(_a0 *dao.LocalUser, _a1 error) *MockQuerier_LocalUserGetByID_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_LocalUserGetByID_Call) RunAndReturn(run func(context.Context, string) (*dao.LocalUser, error)) *MockQuerier_LocalUserGetByID_Call {
	_c.Call.Return(run)
	return _c
}

// LocalUserInsert provides a mock function with given fields: ctx, arg
func (_m *MockQuerier) LocalUserInsert(ctx context.Context, arg *dao.LocalUserInsertParams) error {
	ret := _m.Called(ctx, arg)

	if len(ret) == 0 {
		panic("no return value specified for LocalUserInsert")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *dao.LocalUserInsertParams) error); ok {
		r0 = rf(ctx, arg)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockQuerier_LocalUserInsert_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LocalUserInsert'
type MockQuerier_LocalUserInsert_Call struct {
	*mock.Call
}

// LocalUserInsert is a helper method to define mock.On call
//   - ctx context.Context
//   - arg *dao.LocalUserInsertParams
func (_e *MockQuerier_Expecter) LocalUserInsert(ctx interface{}, arg interface{}) *MockQuerier_LocalUserInsert_Call {
	return &MockQuerier_LocalUserInsert_Call{Call: _e.mock.On("LocalUserInsert", ctx, arg)}
}

func (_c *MockQuerier_LocalUserInsert_Call) Run(run func(ctx context.Context, arg *dao.LocalUserInsertParams)) *MockQuerier_LocalUserInsert_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*dao.LocalUserInsertParams))
	})
	return _c
}

func (_c *MockQuerier_LocalUserInsert_Call) Return(_a0 error) *MockQuerier_LocalUserInsert_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockQuerier_LocalUserInsert_Call) RunAndReturn(run func(context.Context, *dao.LocalUserInsertParams) error) *MockQuerier_LocalUserInsert_Call {
	_c.Call.Return(run)
	return _c
}

// LocalUserList provides a mock function with given fields: ctx
func (_m *MockQuerier) LocalUserList(ctx context.Context) ([]*dao.LocalUser, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for LocalUserList")
	}

	var r0 []*dao.LocalUser
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) ([]*dao.LocalUser, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) []*dao.LocalUser); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*dao.LocalUser)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_LocalUserList_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LocalUserList'
type MockQuerier_LocalUserList_Call struct {
	*mock.Call
}

// LocalUserList is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockQuerier_Expecter) LocalUserList(ctx interface{}) *MockQuerier_LocalUserList_Call {
	return &MockQuerier_LocalUserList_Call{Call: _e.mock.On("LocalUserList", ctx)}
}

func (_c *MockQuerier_LocalUserList_Call) Run(run func(ctx context.Context)) *MockQuerier_LocalUserList_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockQuerier_LocalUserList_Call) Return(_a0 []*dao.LocalUser, _a1 error) *MockQuerier_LocalUserList_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_LocalUserList_Call) RunAndReturn(run func(context.Context) ([]*dao.LocalUser, error)) *MockQuerier_LocalUserList_Call {
	_c.Call.Return(run)
	return _c
}

// LocalUserSetPass provides a mock function with given fields: ctx, pwdhash, email
func (_m *MockQuerier) LocalUserSetPass(ctx context.Context, pwdhash string, email string) error {
	ret := _m.Called(ctx, pwdhash, email)

	if len(ret) == 0 {
		panic("no return value specified for LocalUserSetPass")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, pwdhash, email)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockQuerier_LocalUserSetPass_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LocalUserSetPass'
type MockQuerier_LocalUserSetPass_Call struct {
	*mock.Call
}

// LocalUserSetPass is a helper method to define mock.On call
//   - ctx context.Context
//   - pwdhash string
//   - email string
func (_e *MockQuerier_Expecter) LocalUserSetPass(ctx interface{}, pwdhash interface{}, email interface{}) *MockQuerier_LocalUserSetPass_Call {
	return &MockQuerier_LocalUserSetPass_Call{Call: _e.mock.On("LocalUserSetPass", ctx, pwdhash, email)}
}

func (_c *MockQuerier_LocalUserSetPass_Call) Run(run func(ctx context.Context, pwdhash string, email string)) *MockQuerier_LocalUserSetPass_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockQuerier_LocalUserSetPass_Call) Return(_a0 error) *MockQuerier_LocalUserSetPass_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockQuerier_LocalUserSetPass_Call) RunAndReturn(run func(context.Context, string, string) error) *MockQuerier_LocalUserSetPass_Call {
	_c.Call.Return(run)
	return _c
}

// LocalUserUpdate provides a mock function with given fields: ctx, roles, email
func (_m *MockQuerier) LocalUserUpdate(ctx context.Context, roles string, email string) error {
	ret := _m.Called(ctx, roles, email)

	if len(ret) == 0 {
		panic("no return value specified for LocalUserUpdate")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, roles, email)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockQuerier_LocalUserUpdate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LocalUserUpdate'
type MockQuerier_LocalUserUpdate_Call struct {
	*mock.Call
}

// LocalUserUpdate is a helper method to define mock.On call
//   - ctx context.Context
//   - roles string
//   - email string
func (_e *MockQuerier_Expecter) LocalUserUpdate(ctx interface{}, roles interface{}, email interface{}) *MockQuerier_LocalUserUpdate_Call {
	return &MockQuerier_LocalUserUpdate_Call{Call: _e.mock.On("LocalUserUpdate", ctx, roles, email)}
}

func (_c *MockQuerier_LocalUserUpdate_Call) Run(run func(ctx context.Context, roles string, email string)) *MockQuerier_LocalUserUpdate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockQuerier_LocalUserUpdate_Call) Return(_a0 error) *MockQuerier_LocalUserUpdate_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockQuerier_LocalUserUpdate_Call) RunAndReturn(run func(context.Context, string, string) error) *MockQuerier_LocalUserUpdate_Call {
	_c.Call.Return(run)
	return _c
}

// WalletInsert provides a mock function with given fields: ctx, arg
func (_m *MockQuerier) WalletInsert(ctx context.Context, arg *dao.WalletInsertParams) error {
	ret := _m.Called(ctx, arg)

	if len(ret) == 0 {
		panic("no return value specified for WalletInsert")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *dao.WalletInsertParams) error); ok {
		r0 = rf(ctx, arg)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockQuerier_WalletInsert_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WalletInsert'
type MockQuerier_WalletInsert_Call struct {
	*mock.Call
}

// WalletInsert is a helper method to define mock.On call
//   - ctx context.Context
//   - arg *dao.WalletInsertParams
func (_e *MockQuerier_Expecter) WalletInsert(ctx interface{}, arg interface{}) *MockQuerier_WalletInsert_Call {
	return &MockQuerier_WalletInsert_Call{Call: _e.mock.On("WalletInsert", ctx, arg)}
}

func (_c *MockQuerier_WalletInsert_Call) Run(run func(ctx context.Context, arg *dao.WalletInsertParams)) *MockQuerier_WalletInsert_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*dao.WalletInsertParams))
	})
	return _c
}

func (_c *MockQuerier_WalletInsert_Call) Return(_a0 error) *MockQuerier_WalletInsert_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockQuerier_WalletInsert_Call) RunAndReturn(run func(context.Context, *dao.WalletInsertParams) error) *MockQuerier_WalletInsert_Call {
	_c.Call.Return(run)
	return _c
}

// WalletUpdateBalance provides a mock function with given fields: ctx, balance, iD
func (_m *MockQuerier) WalletUpdateBalance(ctx context.Context, balance float64, iD string) error {
	ret := _m.Called(ctx, balance, iD)

	if len(ret) == 0 {
		panic("no return value specified for WalletUpdateBalance")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, float64, string) error); ok {
		r0 = rf(ctx, balance, iD)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockQuerier_WalletUpdateBalance_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WalletUpdateBalance'
type MockQuerier_WalletUpdateBalance_Call struct {
	*mock.Call
}

// WalletUpdateBalance is a helper method to define mock.On call
//   - ctx context.Context
//   - balance float64
//   - iD string
func (_e *MockQuerier_Expecter) WalletUpdateBalance(ctx interface{}, balance interface{}, iD interface{}) *MockQuerier_WalletUpdateBalance_Call {
	return &MockQuerier_WalletUpdateBalance_Call{Call: _e.mock.On("WalletUpdateBalance", ctx, balance, iD)}
}

func (_c *MockQuerier_WalletUpdateBalance_Call) Run(run func(ctx context.Context, balance float64, iD string)) *MockQuerier_WalletUpdateBalance_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(float64), args[2].(string))
	})
	return _c
}

func (_c *MockQuerier_WalletUpdateBalance_Call) Return(_a0 error) *MockQuerier_WalletUpdateBalance_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockQuerier_WalletUpdateBalance_Call) RunAndReturn(run func(context.Context, float64, string) error) *MockQuerier_WalletUpdateBalance_Call {
	_c.Call.Return(run)
	return _c
}

// WalletsByAdmin provides a mock function with given fields: ctx
func (_m *MockQuerier) WalletsByAdmin(ctx context.Context) ([]*dao.Wallet, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for WalletsByAdmin")
	}

	var r0 []*dao.Wallet
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) ([]*dao.Wallet, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) []*dao.Wallet); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*dao.Wallet)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_WalletsByAdmin_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WalletsByAdmin'
type MockQuerier_WalletsByAdmin_Call struct {
	*mock.Call
}

// WalletsByAdmin is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockQuerier_Expecter) WalletsByAdmin(ctx interface{}) *MockQuerier_WalletsByAdmin_Call {
	return &MockQuerier_WalletsByAdmin_Call{Call: _e.mock.On("WalletsByAdmin", ctx)}
}

func (_c *MockQuerier_WalletsByAdmin_Call) Run(run func(ctx context.Context)) *MockQuerier_WalletsByAdmin_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockQuerier_WalletsByAdmin_Call) Return(_a0 []*dao.Wallet, _a1 error) *MockQuerier_WalletsByAdmin_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_WalletsByAdmin_Call) RunAndReturn(run func(context.Context) ([]*dao.Wallet, error)) *MockQuerier_WalletsByAdmin_Call {
	_c.Call.Return(run)
	return _c
}

// WalletsByUser provides a mock function with given fields: ctx, userID
func (_m *MockQuerier) WalletsByUser(ctx context.Context, userID string) ([]*dao.Wallet, error) {
	ret := _m.Called(ctx, userID)

	if len(ret) == 0 {
		panic("no return value specified for WalletsByUser")
	}

	var r0 []*dao.Wallet
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) ([]*dao.Wallet, error)); ok {
		return rf(ctx, userID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) []*dao.Wallet); ok {
		r0 = rf(ctx, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*dao.Wallet)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, userID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_WalletsByUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WalletsByUser'
type MockQuerier_WalletsByUser_Call struct {
	*mock.Call
}

// WalletsByUser is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
func (_e *MockQuerier_Expecter) WalletsByUser(ctx interface{}, userID interface{}) *MockQuerier_WalletsByUser_Call {
	return &MockQuerier_WalletsByUser_Call{Call: _e.mock.On("WalletsByUser", ctx, userID)}
}

func (_c *MockQuerier_WalletsByUser_Call) Run(run func(ctx context.Context, userID string)) *MockQuerier_WalletsByUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockQuerier_WalletsByUser_Call) Return(_a0 []*dao.Wallet, _a1 error) *MockQuerier_WalletsByUser_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_WalletsByUser_Call) RunAndReturn(run func(context.Context, string) ([]*dao.Wallet, error)) *MockQuerier_WalletsByUser_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockQuerier creates a new instance of MockQuerier. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockQuerier(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockQuerier {
	mock := &MockQuerier{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
